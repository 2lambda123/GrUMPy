<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>coinor.grumpy.polyhedron2D API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>coinor.grumpy.polyhedron2D</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from __future__ import division
from __future__ import print_function
from builtins import range
from builtins import object
from past.utils import old_div
import numpy as np
from pypolyhedron.polyhedron import Vrep, Hrep
import matplotlib.pyplot as plt
import matplotlib.lines as lines
from math import ceil, floor

class Polyhedron2D(object):
    def __init__(self, points = None, rays = None, A = None, b = None):
        have_rep = False
        if points is not None or rays is not None:
            self.vrep = Vrep(points, rays)
            self.hrep = Hrep(self.vrep.A, self.vrep.b)
            have_rep = True
        if A is not None and b is not None:
            self.hrep = Hrep(A, b)
            have_rep = True
        if not have_rep:
            raise RuntimeError(&#39;Must provide either generators or constraint&#39;+
                               &#39;matrix&#39;)
        self.ray_indices = []
        for i in range(len(self.hrep.generators)):
            if not self.hrep.is_vertex[i]:
                self.ray_indices.append(i)
        self.min_point = None
        self.max_point = None
        self.xlim = None
        self.ylim = None
        self.fig = None
        self.ax = None
        
    def make_integer_hull(self):
        if self.min_point is None or self.max_point is None:
            self.determine_hull_size()
        v = []
        for i in range(int(ceil(round(self.min_point[0], 3))), 
                       int(ceil(round(self.max_point[0], 3)))+1):
            for j in range(int(ceil(round(self.min_point[1], 3))), 
                           int(ceil(round(self.max_point[1], 3)))+1):
                if np.alltrue(np.dot(self.hrep.A, [i, j]) &lt;= self.hrep.b):
                    v.append([i, j])
        r = [self.hrep.generators[self.ray_indices[i]].tolist() 
             for i in range(len(self.ray_indices))]
        return Polyhedron2D(points = v, rays = r)

    def determine_hull_size(self):
        self.min_point = np.array([10000, 10000])
        self.max_point = np.array([-10000, -10000])
        for i in range(len(self.hrep.generators)):
            if self.hrep.is_vertex[i]:
                self.max_point = np.maximum(self.max_point, self.hrep.generators[i])
                self.min_point = np.minimum(self.min_point, self.hrep.generators[i])

    def determine_plot_size(self, padding = [-1, 2]):
        if self.min_point is None or self.max_point is None:
            self.determine_hull_size()
        self.xlim = [self.min_point[0], self.max_point[0]]
        self.ylim = [self.min_point[1], self.max_point[1]]
        if len(self.ray_indices) &gt; 0:
            current_point = self.ray_indices[0]
            ray = self.hrep.generators[current_point]
            if self.hrep.is_vertex[self.hrep.adj[self.ray_indices[0]][0]]:
                vertex = self.hrep.generators[self.hrep.adj[self.ray_indices[0]][0]]
                next_point = self.hrep.adj[self.ray_indices[0]][0]
            else:
                vertex = self.hrep.generators[
                    self.hrep.adj[self.ray_indices[0]][1]]
                next_point = self.hrep.adj[self.ray_indices[0]][1]
            if ray[0] &lt; 0:
                x_lim = old_div((vertex[0] - self.min_point[0]),-float(ray[0]))
            elif ray[0] &gt; 0:
                x_lim = old_div((self.max_point[0] - vertex[0]),-float(ray[0]))
            else:
                x_lim = 10000
            if ray[1] &lt; 0:
                y_lim = old_div((vertex[1] - self.min_point[1]),-float(ray[1]))
            elif ray[1] &gt; 0:
                y_lim = old_div((self.max_point[1] - vertex[1]),-float(ray[1])) 
            else:
                y_lim = 10000
            lim = min(x_lim, y_lim) + 1
            plot_max = np.maximum(self.max_point, vertex + lim*ray)
            plot_min = np.minimum(self.min_point, vertex + lim*ray)
            self.xlim = [plot_min[0], plot_max[0]]
            self.ylim = [plot_min[1], plot_max[1]]
        else:
            current_point = 0
            next_point = self.hrep.adj[0][0]
        for _ in range(len(self.hrep.generators)):
            prev_point = current_point
            current_point = next_point
            if not self.hrep.is_vertex[current_point]:
                ray = self.hrep.generators[current_point]
                vertex = self.hrep.generators[prev_point]
                if ray[0] &lt; 0:
                    x_lim = old_div((vertex[0] - self.min_point[0]),-float(ray[0]))
                elif ray[0] &gt; 0:
                    x_lim = old_div((self.max_point[0] - vertex[0]),float(ray[0]))
                else:
                    x_lim = 10000
                if ray[1] &lt; 0:
                    y_lim = old_div((vertex[1] - self.min_point[1]),-float(ray[1]))
                elif ray[1] &gt; 0:
                    y_lim = old_div((self.max_point[1] - vertex[1]),float(ray[1]))
                else:
                    y_lim = 10000 
                lim = min(x_lim, y_lim) + 1
                plot_max = np.maximum(self.max_point, vertex + lim*ray)
                plot_min = np.minimum(self.min_point, vertex + lim*ray)
                self.xlim = [plot_min[0], plot_max[0]]
                self.ylim = [plot_min[1], plot_max[1]]
                break
            if self.hrep.adj[current_point][0] != prev_point:
                next_point = self.hrep.adj[current_point][0]
            else:
                next_point = self.hrep.adj[current_point][1]
    
        self.xlim = np.array(np.floor([self.xlim[i] + padding[i] for i in [0,1]]))
        self.ylim = np.array(np.floor([self.ylim[i] + padding[i] for i in [0,1]]))

class Figure(object):

    def __init__(self):
        self.fig = None

    def initialize(self):
        self.fig = plt.figure()
        self.ax = self.fig.add_subplot(111)
        self.ax.grid()

    def add_polyhedron(self, p, color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = None,
                       show_int_points = False):
        if self.fig is None:
            self.initialize()
        if p.xlim is None or p.ylim is None:
            p.determine_plot_size()
        x, y = [], []
        if len(p.ray_indices) &gt; 0:
            current_point = p.ray_indices[0]
            ray = p.hrep.generators[current_point]
            if p.hrep.is_vertex[p.hrep.adj[p.ray_indices[0]][0]]:
                vertex = p.hrep.generators[
                    p.hrep.adj[p.ray_indices[0]][0]]
                next_point = p.hrep.adj[p.ray_indices[0]][0]
            else:
                vertex = p.hrep.generators[
                    p.hrep.adj[p.ray_indices[0]][1]]
                next_point = p.hrep.adj[p.ray_indices[0]][1]
            if ray[0] &lt; 0:
                x_lim = old_div((vertex[0] - p.xlim[0]),-float(ray[0]))
            elif ray[0] &gt; 0:
                x_lim = old_div((p.xlim[1] - vertex[0]),float(ray[0]))
            else:
                x_lim = 10000
            if ray[1] &lt; 0:
                y_lim = old_div((vertex[1] - p.ylim[0]),-float(ray[1]))
            elif ray[1] &gt; 0:
                y_lim = old_div((p.ylim[1] - vertex[1]),float(ray[1])) 
            else:
                y_lim = 10000
            lim = min(x_lim, y_lim)*0.95
            self.ax.arrow(vertex[0], vertex[1], lim*ray[0], lim*ray[1], 
                          head_width = 0.02*(p.xlim[1] - p.xlim[0]), 
                          head_length = 0.03*(p.xlim[1] - p.xlim[0]), 
                          color = color, linestyle = linestyle)
        else:
            current_point = 0
            next_point = p.hrep.adj[0][0]
            x.append(p.hrep.generators[current_point][0])
            y.append(p.hrep.generators[current_point][1])
        for i in range(len(p.hrep.generators)):
            prev_point = current_point
            current_point = next_point
            if not p.hrep.is_vertex[current_point]:
                ray = p.hrep.generators[current_point]
                vertex = p.hrep.generators[prev_point]
                if ray[0] &lt; 0:
                    x_lim = old_div((vertex[0] - p.xlim[0]),-float(ray[0]))
                elif ray[0] &gt; 0:
                    x_lim = old_div((p.xlim[1] - vertex[0]),float(ray[0]))
                else:
                    x_lim = 10000
                if ray[1] &lt; 0:
                    y_lim = old_div((vertex[1] - p.ylim[0]),-float(ray[1]))
                elif ray[1] &gt; 0:
                    y_lim = old_div((p.ylim[1] - vertex[1]),float(ray[1]))
                else:
                    y_lim = 10000 
                lim = min(x_lim, y_lim)*0.95
                self.ax.arrow(vertex[0], vertex[1], lim*ray[0], lim*ray[1], 
                              head_width = 0.02*(p.ylim[1] - 
                                                 p.xlim[0]), 
                              head_length = 0.03*(p.ylim[1] - 
                                                  p.xlim[0]), 
                              color = color, linestyle = linestyle)
                break
            x.append(p.hrep.generators[current_point][0])
            y.append(p.hrep.generators[current_point][1])
            if p.hrep.adj[current_point][0] != prev_point:
                next_point = p.hrep.adj[current_point][0]
            else:
                next_point = p.hrep.adj[current_point][1]
        if linestyle == &#39;dashed&#39;:
            linestyle = &#39;--&#39;
        if linestyle == &#39;solid&#39;:
            linestyle = &#39;-&#39;
        line = lines.Line2D(x, y, color = color, linestyle = linestyle,
                            label = label)
        self.ax.add_line(line)
        if show_int_points:
            for i in range(int(ceil(p.min_point[0])), 
                           int(ceil(p.max_point[0]))+1):
                for j in range(int(ceil(p.min_point[1])), 
                               int(ceil(p.max_point[1]))+1):
                    if np.alltrue(np.dot(p.hrep.A, [i, j]) &lt;= p.hrep.b):
                        self.add_point((i, j), radius = 0.02, color = &#39;black&#39;)

    def add_line_segment(self, point1, point2, color = &#39;blue&#39;, linestyle = &#39;solid&#39;,
                         label = None):
        if linestyle == &#39;dashed&#39;:
            linestyle = &#39;--&#39;
        if linestyle == &#39;solid&#39;:
            linestyle = &#39;-&#39;
        line = lines.Line2D([point1[0], point2[0]], 
                            [point1[1], point2[1]], 
                            color = color, linestyle = linestyle,
                            label = label)
        self.ax.add_line(line)
        
    def add_line(self, coeffs, level, xlim = None, ylim = None, 
                 color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = None):
        if self.fig is None:
            self.initialize()
        if xlim is None or ylim is None:
            print(&#39;Must have plot_max and plot_min set in order to add line&#39;)
            return
        x_intercept = None
        y_intercept = None
        x = []
        y = []
        if coeffs[0] == 0 and coeffs[1] == 0:
            print(&#39;Trying to plot line with zero coefficients...&#39;)
            return
        if coeffs[0] == 0:
            x = [xlim[0], xlim[1]]
            y = [old_div(level,coeffs[1]), old_div(level,coeffs[1])]
        else:
            x_intercept = [old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]),
                           old_div(float(level - ylim[1]*coeffs[1]),coeffs[0])]
        if coeffs[1] == 0:
            x = [old_div(level,coeffs[0]), old_div(level,coeffs[0])]
            y = [ylim[0], ylim[1]]
        else:
            y_intercept = [old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]),
                           old_div(float(level - xlim[1]*coeffs[0]),coeffs[1])]
        
        if x_intercept is not None and y_intercept is not None:
            if old_div(coeffs[0],coeffs[1]) &lt; 0:
                if y_intercept[1] &gt; ylim[1]:
                    y.append(ylim[1])
                    x.append(old_div(float(level - ylim[1]*coeffs[1]),coeffs[0]))
                elif y_intercept[1] &lt; ylim[0]:
                    return
                else:
                    x.append(xlim[1])
                    y.append(old_div(float(level - xlim[1]*coeffs[0]),coeffs[1]))
                if y_intercept[0] &lt; ylim[0]:
                    y.append(ylim[0])
                    x.append(old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]))
                elif y_intercept[0] &gt; ylim[1]:
                    return
                else:
                    x.append(xlim[0])
                    y.append(old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]))
            else:
                if y_intercept[1] &lt; ylim[0]:
                    y.append(ylim[0])
                    x.append(old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]))
                elif y_intercept[1] &gt; ylim[1]:
                    return
                else:
                    x.append(xlim[1])
                    y.append(old_div(float(level - xlim[1]*coeffs[0]),coeffs[1]))
                if y_intercept[1] &gt; ylim[1]:
                    y.append(ylim[1])
                    x.append(old_div(float(level - ylim[1]*coeffs[1]),coeffs[0]))
                elif y_intercept[0] &lt; ylim[0]:
                    return
                else:
                    x.append(xlim[0])
                    y.append(old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]))
    
        if linestyle == &#39;dashed&#39;:
            linestyle = &#39;--&#39;
        if linestyle == &#39;solid&#39;:
            linestyle = &#39;-&#39;
        line = lines.Line2D(x, y, color = color, linestyle = linestyle,
                            label = label)
        self.ax.add_line(line)
    
    def add_point(self, center, radius = .02, color = &#39;red&#39;, ):
        if self.fig is None:
            self.initialize()
        self.ax.add_patch(plt.Circle(center, radius = radius, color = color))
    
    def add_text(self, loc, text):
        plt.text(loc[0], loc[1], text)
        
    def set_xlim(self, xlim):
        self.ax.set_xlim(xlim)

    def set_ylim(self, ylim):
        self.ax.set_ylim(ylim)

    def show(self):
        plt.legend()
        plt.show()
        self.fig = None

if __name__ == &#39;__main__&#39;:
    #points = np.random.random ((20,2))
    #p = make_hull(points)

    f = Figure()
    p = Polyhedron2D(A = [[4, 1], [1, 4], [1, -1], [-1, 0], [0, -1]], 
                     b = [28, 27, 1, 0, 0])
    f.add_polyhedron(p, color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = &#39;p&#39;,
                     show_int_points = True)
    f.set_xlim(p.xlim)
    f.set_ylim(p.ylim)
    pI = p.make_integer_hull()
    f.add_polyhedron(pI, color = &#39;red&#39;, linestyle = &#39;dashed&#39;, label = &#39;pI&#39;) 
    f.add_point((5.666,5.333), 0.02, &#39;red&#39;)
    f.add_text((5.7, 5.4), r&#39;$(17/3, 16/3)$&#39;)
    f.add_line([3, 2], 27, p.xlim, p.ylim,
               color = &#39;green&#39;, linestyle = &#39;dashed&#39;)
    f.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coinor.grumpy.polyhedron2D.Figure"><code class="flex name class">
<span>class <span class="ident">Figure</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Figure(object):

    def __init__(self):
        self.fig = None

    def initialize(self):
        self.fig = plt.figure()
        self.ax = self.fig.add_subplot(111)
        self.ax.grid()

    def add_polyhedron(self, p, color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = None,
                       show_int_points = False):
        if self.fig is None:
            self.initialize()
        if p.xlim is None or p.ylim is None:
            p.determine_plot_size()
        x, y = [], []
        if len(p.ray_indices) &gt; 0:
            current_point = p.ray_indices[0]
            ray = p.hrep.generators[current_point]
            if p.hrep.is_vertex[p.hrep.adj[p.ray_indices[0]][0]]:
                vertex = p.hrep.generators[
                    p.hrep.adj[p.ray_indices[0]][0]]
                next_point = p.hrep.adj[p.ray_indices[0]][0]
            else:
                vertex = p.hrep.generators[
                    p.hrep.adj[p.ray_indices[0]][1]]
                next_point = p.hrep.adj[p.ray_indices[0]][1]
            if ray[0] &lt; 0:
                x_lim = old_div((vertex[0] - p.xlim[0]),-float(ray[0]))
            elif ray[0] &gt; 0:
                x_lim = old_div((p.xlim[1] - vertex[0]),float(ray[0]))
            else:
                x_lim = 10000
            if ray[1] &lt; 0:
                y_lim = old_div((vertex[1] - p.ylim[0]),-float(ray[1]))
            elif ray[1] &gt; 0:
                y_lim = old_div((p.ylim[1] - vertex[1]),float(ray[1])) 
            else:
                y_lim = 10000
            lim = min(x_lim, y_lim)*0.95
            self.ax.arrow(vertex[0], vertex[1], lim*ray[0], lim*ray[1], 
                          head_width = 0.02*(p.xlim[1] - p.xlim[0]), 
                          head_length = 0.03*(p.xlim[1] - p.xlim[0]), 
                          color = color, linestyle = linestyle)
        else:
            current_point = 0
            next_point = p.hrep.adj[0][0]
            x.append(p.hrep.generators[current_point][0])
            y.append(p.hrep.generators[current_point][1])
        for i in range(len(p.hrep.generators)):
            prev_point = current_point
            current_point = next_point
            if not p.hrep.is_vertex[current_point]:
                ray = p.hrep.generators[current_point]
                vertex = p.hrep.generators[prev_point]
                if ray[0] &lt; 0:
                    x_lim = old_div((vertex[0] - p.xlim[0]),-float(ray[0]))
                elif ray[0] &gt; 0:
                    x_lim = old_div((p.xlim[1] - vertex[0]),float(ray[0]))
                else:
                    x_lim = 10000
                if ray[1] &lt; 0:
                    y_lim = old_div((vertex[1] - p.ylim[0]),-float(ray[1]))
                elif ray[1] &gt; 0:
                    y_lim = old_div((p.ylim[1] - vertex[1]),float(ray[1]))
                else:
                    y_lim = 10000 
                lim = min(x_lim, y_lim)*0.95
                self.ax.arrow(vertex[0], vertex[1], lim*ray[0], lim*ray[1], 
                              head_width = 0.02*(p.ylim[1] - 
                                                 p.xlim[0]), 
                              head_length = 0.03*(p.ylim[1] - 
                                                  p.xlim[0]), 
                              color = color, linestyle = linestyle)
                break
            x.append(p.hrep.generators[current_point][0])
            y.append(p.hrep.generators[current_point][1])
            if p.hrep.adj[current_point][0] != prev_point:
                next_point = p.hrep.adj[current_point][0]
            else:
                next_point = p.hrep.adj[current_point][1]
        if linestyle == &#39;dashed&#39;:
            linestyle = &#39;--&#39;
        if linestyle == &#39;solid&#39;:
            linestyle = &#39;-&#39;
        line = lines.Line2D(x, y, color = color, linestyle = linestyle,
                            label = label)
        self.ax.add_line(line)
        if show_int_points:
            for i in range(int(ceil(p.min_point[0])), 
                           int(ceil(p.max_point[0]))+1):
                for j in range(int(ceil(p.min_point[1])), 
                               int(ceil(p.max_point[1]))+1):
                    if np.alltrue(np.dot(p.hrep.A, [i, j]) &lt;= p.hrep.b):
                        self.add_point((i, j), radius = 0.02, color = &#39;black&#39;)

    def add_line_segment(self, point1, point2, color = &#39;blue&#39;, linestyle = &#39;solid&#39;,
                         label = None):
        if linestyle == &#39;dashed&#39;:
            linestyle = &#39;--&#39;
        if linestyle == &#39;solid&#39;:
            linestyle = &#39;-&#39;
        line = lines.Line2D([point1[0], point2[0]], 
                            [point1[1], point2[1]], 
                            color = color, linestyle = linestyle,
                            label = label)
        self.ax.add_line(line)
        
    def add_line(self, coeffs, level, xlim = None, ylim = None, 
                 color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = None):
        if self.fig is None:
            self.initialize()
        if xlim is None or ylim is None:
            print(&#39;Must have plot_max and plot_min set in order to add line&#39;)
            return
        x_intercept = None
        y_intercept = None
        x = []
        y = []
        if coeffs[0] == 0 and coeffs[1] == 0:
            print(&#39;Trying to plot line with zero coefficients...&#39;)
            return
        if coeffs[0] == 0:
            x = [xlim[0], xlim[1]]
            y = [old_div(level,coeffs[1]), old_div(level,coeffs[1])]
        else:
            x_intercept = [old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]),
                           old_div(float(level - ylim[1]*coeffs[1]),coeffs[0])]
        if coeffs[1] == 0:
            x = [old_div(level,coeffs[0]), old_div(level,coeffs[0])]
            y = [ylim[0], ylim[1]]
        else:
            y_intercept = [old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]),
                           old_div(float(level - xlim[1]*coeffs[0]),coeffs[1])]
        
        if x_intercept is not None and y_intercept is not None:
            if old_div(coeffs[0],coeffs[1]) &lt; 0:
                if y_intercept[1] &gt; ylim[1]:
                    y.append(ylim[1])
                    x.append(old_div(float(level - ylim[1]*coeffs[1]),coeffs[0]))
                elif y_intercept[1] &lt; ylim[0]:
                    return
                else:
                    x.append(xlim[1])
                    y.append(old_div(float(level - xlim[1]*coeffs[0]),coeffs[1]))
                if y_intercept[0] &lt; ylim[0]:
                    y.append(ylim[0])
                    x.append(old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]))
                elif y_intercept[0] &gt; ylim[1]:
                    return
                else:
                    x.append(xlim[0])
                    y.append(old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]))
            else:
                if y_intercept[1] &lt; ylim[0]:
                    y.append(ylim[0])
                    x.append(old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]))
                elif y_intercept[1] &gt; ylim[1]:
                    return
                else:
                    x.append(xlim[1])
                    y.append(old_div(float(level - xlim[1]*coeffs[0]),coeffs[1]))
                if y_intercept[1] &gt; ylim[1]:
                    y.append(ylim[1])
                    x.append(old_div(float(level - ylim[1]*coeffs[1]),coeffs[0]))
                elif y_intercept[0] &lt; ylim[0]:
                    return
                else:
                    x.append(xlim[0])
                    y.append(old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]))
    
        if linestyle == &#39;dashed&#39;:
            linestyle = &#39;--&#39;
        if linestyle == &#39;solid&#39;:
            linestyle = &#39;-&#39;
        line = lines.Line2D(x, y, color = color, linestyle = linestyle,
                            label = label)
        self.ax.add_line(line)
    
    def add_point(self, center, radius = .02, color = &#39;red&#39;, ):
        if self.fig is None:
            self.initialize()
        self.ax.add_patch(plt.Circle(center, radius = radius, color = color))
    
    def add_text(self, loc, text):
        plt.text(loc[0], loc[1], text)
        
    def set_xlim(self, xlim):
        self.ax.set_xlim(xlim)

    def set_ylim(self, ylim):
        self.ax.set_ylim(ylim)

    def show(self):
        plt.legend()
        plt.show()
        self.fig = None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coinor.grumpy.polyhedron2D.Figure.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self):
    self.fig = None</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.add_line"><code class="name flex">
<span>def <span class="ident">add_line</span></span>(<span>self, coeffs, level, xlim=None, ylim=None, color=&#39;blue&#39;, linestyle=&#39;solid&#39;, label=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_line(self, coeffs, level, xlim = None, ylim = None, 
             color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = None):
    if self.fig is None:
        self.initialize()
    if xlim is None or ylim is None:
        print(&#39;Must have plot_max and plot_min set in order to add line&#39;)
        return
    x_intercept = None
    y_intercept = None
    x = []
    y = []
    if coeffs[0] == 0 and coeffs[1] == 0:
        print(&#39;Trying to plot line with zero coefficients...&#39;)
        return
    if coeffs[0] == 0:
        x = [xlim[0], xlim[1]]
        y = [old_div(level,coeffs[1]), old_div(level,coeffs[1])]
    else:
        x_intercept = [old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]),
                       old_div(float(level - ylim[1]*coeffs[1]),coeffs[0])]
    if coeffs[1] == 0:
        x = [old_div(level,coeffs[0]), old_div(level,coeffs[0])]
        y = [ylim[0], ylim[1]]
    else:
        y_intercept = [old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]),
                       old_div(float(level - xlim[1]*coeffs[0]),coeffs[1])]
    
    if x_intercept is not None and y_intercept is not None:
        if old_div(coeffs[0],coeffs[1]) &lt; 0:
            if y_intercept[1] &gt; ylim[1]:
                y.append(ylim[1])
                x.append(old_div(float(level - ylim[1]*coeffs[1]),coeffs[0]))
            elif y_intercept[1] &lt; ylim[0]:
                return
            else:
                x.append(xlim[1])
                y.append(old_div(float(level - xlim[1]*coeffs[0]),coeffs[1]))
            if y_intercept[0] &lt; ylim[0]:
                y.append(ylim[0])
                x.append(old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]))
            elif y_intercept[0] &gt; ylim[1]:
                return
            else:
                x.append(xlim[0])
                y.append(old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]))
        else:
            if y_intercept[1] &lt; ylim[0]:
                y.append(ylim[0])
                x.append(old_div(float(level - ylim[0]*coeffs[1]),coeffs[0]))
            elif y_intercept[1] &gt; ylim[1]:
                return
            else:
                x.append(xlim[1])
                y.append(old_div(float(level - xlim[1]*coeffs[0]),coeffs[1]))
            if y_intercept[1] &gt; ylim[1]:
                y.append(ylim[1])
                x.append(old_div(float(level - ylim[1]*coeffs[1]),coeffs[0]))
            elif y_intercept[0] &lt; ylim[0]:
                return
            else:
                x.append(xlim[0])
                y.append(old_div(float(level - xlim[0]*coeffs[0]),coeffs[1]))

    if linestyle == &#39;dashed&#39;:
        linestyle = &#39;--&#39;
    if linestyle == &#39;solid&#39;:
        linestyle = &#39;-&#39;
    line = lines.Line2D(x, y, color = color, linestyle = linestyle,
                        label = label)
    self.ax.add_line(line)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.add_line_segment"><code class="name flex">
<span>def <span class="ident">add_line_segment</span></span>(<span>self, point1, point2, color=&#39;blue&#39;, linestyle=&#39;solid&#39;, label=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_line_segment(self, point1, point2, color = &#39;blue&#39;, linestyle = &#39;solid&#39;,
                     label = None):
    if linestyle == &#39;dashed&#39;:
        linestyle = &#39;--&#39;
    if linestyle == &#39;solid&#39;:
        linestyle = &#39;-&#39;
    line = lines.Line2D([point1[0], point2[0]], 
                        [point1[1], point2[1]], 
                        color = color, linestyle = linestyle,
                        label = label)
    self.ax.add_line(line)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.add_point"><code class="name flex">
<span>def <span class="ident">add_point</span></span>(<span>self, center, radius=0.02, color=&#39;red&#39;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_point(self, center, radius = .02, color = &#39;red&#39;, ):
    if self.fig is None:
        self.initialize()
    self.ax.add_patch(plt.Circle(center, radius = radius, color = color))</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.add_polyhedron"><code class="name flex">
<span>def <span class="ident">add_polyhedron</span></span>(<span>self, p, color=&#39;blue&#39;, linestyle=&#39;solid&#39;, label=None, show_int_points=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_polyhedron(self, p, color = &#39;blue&#39;, linestyle = &#39;solid&#39;, label = None,
                   show_int_points = False):
    if self.fig is None:
        self.initialize()
    if p.xlim is None or p.ylim is None:
        p.determine_plot_size()
    x, y = [], []
    if len(p.ray_indices) &gt; 0:
        current_point = p.ray_indices[0]
        ray = p.hrep.generators[current_point]
        if p.hrep.is_vertex[p.hrep.adj[p.ray_indices[0]][0]]:
            vertex = p.hrep.generators[
                p.hrep.adj[p.ray_indices[0]][0]]
            next_point = p.hrep.adj[p.ray_indices[0]][0]
        else:
            vertex = p.hrep.generators[
                p.hrep.adj[p.ray_indices[0]][1]]
            next_point = p.hrep.adj[p.ray_indices[0]][1]
        if ray[0] &lt; 0:
            x_lim = old_div((vertex[0] - p.xlim[0]),-float(ray[0]))
        elif ray[0] &gt; 0:
            x_lim = old_div((p.xlim[1] - vertex[0]),float(ray[0]))
        else:
            x_lim = 10000
        if ray[1] &lt; 0:
            y_lim = old_div((vertex[1] - p.ylim[0]),-float(ray[1]))
        elif ray[1] &gt; 0:
            y_lim = old_div((p.ylim[1] - vertex[1]),float(ray[1])) 
        else:
            y_lim = 10000
        lim = min(x_lim, y_lim)*0.95
        self.ax.arrow(vertex[0], vertex[1], lim*ray[0], lim*ray[1], 
                      head_width = 0.02*(p.xlim[1] - p.xlim[0]), 
                      head_length = 0.03*(p.xlim[1] - p.xlim[0]), 
                      color = color, linestyle = linestyle)
    else:
        current_point = 0
        next_point = p.hrep.adj[0][0]
        x.append(p.hrep.generators[current_point][0])
        y.append(p.hrep.generators[current_point][1])
    for i in range(len(p.hrep.generators)):
        prev_point = current_point
        current_point = next_point
        if not p.hrep.is_vertex[current_point]:
            ray = p.hrep.generators[current_point]
            vertex = p.hrep.generators[prev_point]
            if ray[0] &lt; 0:
                x_lim = old_div((vertex[0] - p.xlim[0]),-float(ray[0]))
            elif ray[0] &gt; 0:
                x_lim = old_div((p.xlim[1] - vertex[0]),float(ray[0]))
            else:
                x_lim = 10000
            if ray[1] &lt; 0:
                y_lim = old_div((vertex[1] - p.ylim[0]),-float(ray[1]))
            elif ray[1] &gt; 0:
                y_lim = old_div((p.ylim[1] - vertex[1]),float(ray[1]))
            else:
                y_lim = 10000 
            lim = min(x_lim, y_lim)*0.95
            self.ax.arrow(vertex[0], vertex[1], lim*ray[0], lim*ray[1], 
                          head_width = 0.02*(p.ylim[1] - 
                                             p.xlim[0]), 
                          head_length = 0.03*(p.ylim[1] - 
                                              p.xlim[0]), 
                          color = color, linestyle = linestyle)
            break
        x.append(p.hrep.generators[current_point][0])
        y.append(p.hrep.generators[current_point][1])
        if p.hrep.adj[current_point][0] != prev_point:
            next_point = p.hrep.adj[current_point][0]
        else:
            next_point = p.hrep.adj[current_point][1]
    if linestyle == &#39;dashed&#39;:
        linestyle = &#39;--&#39;
    if linestyle == &#39;solid&#39;:
        linestyle = &#39;-&#39;
    line = lines.Line2D(x, y, color = color, linestyle = linestyle,
                        label = label)
    self.ax.add_line(line)
    if show_int_points:
        for i in range(int(ceil(p.min_point[0])), 
                       int(ceil(p.max_point[0]))+1):
            for j in range(int(ceil(p.min_point[1])), 
                           int(ceil(p.max_point[1]))+1):
                if np.alltrue(np.dot(p.hrep.A, [i, j]) &lt;= p.hrep.b):
                    self.add_point((i, j), radius = 0.02, color = &#39;black&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.add_text"><code class="name flex">
<span>def <span class="ident">add_text</span></span>(<span>self, loc, text)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_text(self, loc, text):
    plt.text(loc[0], loc[1], text)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def initialize(self):
    self.fig = plt.figure()
    self.ax = self.fig.add_subplot(111)
    self.ax.grid()</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.set_xlim"><code class="name flex">
<span>def <span class="ident">set_xlim</span></span>(<span>self, xlim)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_xlim(self, xlim):
    self.ax.set_xlim(xlim)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.set_ylim"><code class="name flex">
<span>def <span class="ident">set_ylim</span></span>(<span>self, ylim)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_ylim(self, ylim):
    self.ax.set_ylim(ylim)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Figure.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self):
    plt.legend()
    plt.show()
    self.fig = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Polyhedron2D"><code class="flex name class">
<span>class <span class="ident">Polyhedron2D</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Polyhedron2D(object):
    def __init__(self, points = None, rays = None, A = None, b = None):
        have_rep = False
        if points is not None or rays is not None:
            self.vrep = Vrep(points, rays)
            self.hrep = Hrep(self.vrep.A, self.vrep.b)
            have_rep = True
        if A is not None and b is not None:
            self.hrep = Hrep(A, b)
            have_rep = True
        if not have_rep:
            raise RuntimeError(&#39;Must provide either generators or constraint&#39;+
                               &#39;matrix&#39;)
        self.ray_indices = []
        for i in range(len(self.hrep.generators)):
            if not self.hrep.is_vertex[i]:
                self.ray_indices.append(i)
        self.min_point = None
        self.max_point = None
        self.xlim = None
        self.ylim = None
        self.fig = None
        self.ax = None
        
    def make_integer_hull(self):
        if self.min_point is None or self.max_point is None:
            self.determine_hull_size()
        v = []
        for i in range(int(ceil(round(self.min_point[0], 3))), 
                       int(ceil(round(self.max_point[0], 3)))+1):
            for j in range(int(ceil(round(self.min_point[1], 3))), 
                           int(ceil(round(self.max_point[1], 3)))+1):
                if np.alltrue(np.dot(self.hrep.A, [i, j]) &lt;= self.hrep.b):
                    v.append([i, j])
        r = [self.hrep.generators[self.ray_indices[i]].tolist() 
             for i in range(len(self.ray_indices))]
        return Polyhedron2D(points = v, rays = r)

    def determine_hull_size(self):
        self.min_point = np.array([10000, 10000])
        self.max_point = np.array([-10000, -10000])
        for i in range(len(self.hrep.generators)):
            if self.hrep.is_vertex[i]:
                self.max_point = np.maximum(self.max_point, self.hrep.generators[i])
                self.min_point = np.minimum(self.min_point, self.hrep.generators[i])

    def determine_plot_size(self, padding = [-1, 2]):
        if self.min_point is None or self.max_point is None:
            self.determine_hull_size()
        self.xlim = [self.min_point[0], self.max_point[0]]
        self.ylim = [self.min_point[1], self.max_point[1]]
        if len(self.ray_indices) &gt; 0:
            current_point = self.ray_indices[0]
            ray = self.hrep.generators[current_point]
            if self.hrep.is_vertex[self.hrep.adj[self.ray_indices[0]][0]]:
                vertex = self.hrep.generators[self.hrep.adj[self.ray_indices[0]][0]]
                next_point = self.hrep.adj[self.ray_indices[0]][0]
            else:
                vertex = self.hrep.generators[
                    self.hrep.adj[self.ray_indices[0]][1]]
                next_point = self.hrep.adj[self.ray_indices[0]][1]
            if ray[0] &lt; 0:
                x_lim = old_div((vertex[0] - self.min_point[0]),-float(ray[0]))
            elif ray[0] &gt; 0:
                x_lim = old_div((self.max_point[0] - vertex[0]),-float(ray[0]))
            else:
                x_lim = 10000
            if ray[1] &lt; 0:
                y_lim = old_div((vertex[1] - self.min_point[1]),-float(ray[1]))
            elif ray[1] &gt; 0:
                y_lim = old_div((self.max_point[1] - vertex[1]),-float(ray[1])) 
            else:
                y_lim = 10000
            lim = min(x_lim, y_lim) + 1
            plot_max = np.maximum(self.max_point, vertex + lim*ray)
            plot_min = np.minimum(self.min_point, vertex + lim*ray)
            self.xlim = [plot_min[0], plot_max[0]]
            self.ylim = [plot_min[1], plot_max[1]]
        else:
            current_point = 0
            next_point = self.hrep.adj[0][0]
        for _ in range(len(self.hrep.generators)):
            prev_point = current_point
            current_point = next_point
            if not self.hrep.is_vertex[current_point]:
                ray = self.hrep.generators[current_point]
                vertex = self.hrep.generators[prev_point]
                if ray[0] &lt; 0:
                    x_lim = old_div((vertex[0] - self.min_point[0]),-float(ray[0]))
                elif ray[0] &gt; 0:
                    x_lim = old_div((self.max_point[0] - vertex[0]),float(ray[0]))
                else:
                    x_lim = 10000
                if ray[1] &lt; 0:
                    y_lim = old_div((vertex[1] - self.min_point[1]),-float(ray[1]))
                elif ray[1] &gt; 0:
                    y_lim = old_div((self.max_point[1] - vertex[1]),float(ray[1]))
                else:
                    y_lim = 10000 
                lim = min(x_lim, y_lim) + 1
                plot_max = np.maximum(self.max_point, vertex + lim*ray)
                plot_min = np.minimum(self.min_point, vertex + lim*ray)
                self.xlim = [plot_min[0], plot_max[0]]
                self.ylim = [plot_min[1], plot_max[1]]
                break
            if self.hrep.adj[current_point][0] != prev_point:
                next_point = self.hrep.adj[current_point][0]
            else:
                next_point = self.hrep.adj[current_point][1]
    
        self.xlim = np.array(np.floor([self.xlim[i] + padding[i] for i in [0,1]]))
        self.ylim = np.array(np.floor([self.ylim[i] + padding[i] for i in [0,1]]))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coinor.grumpy.polyhedron2D.Polyhedron2D.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, points=None, rays=None, A=None, b=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, points = None, rays = None, A = None, b = None):
    have_rep = False
    if points is not None or rays is not None:
        self.vrep = Vrep(points, rays)
        self.hrep = Hrep(self.vrep.A, self.vrep.b)
        have_rep = True
    if A is not None and b is not None:
        self.hrep = Hrep(A, b)
        have_rep = True
    if not have_rep:
        raise RuntimeError(&#39;Must provide either generators or constraint&#39;+
                           &#39;matrix&#39;)
    self.ray_indices = []
    for i in range(len(self.hrep.generators)):
        if not self.hrep.is_vertex[i]:
            self.ray_indices.append(i)
    self.min_point = None
    self.max_point = None
    self.xlim = None
    self.ylim = None
    self.fig = None
    self.ax = None</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Polyhedron2D.determine_hull_size"><code class="name flex">
<span>def <span class="ident">determine_hull_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def determine_hull_size(self):
    self.min_point = np.array([10000, 10000])
    self.max_point = np.array([-10000, -10000])
    for i in range(len(self.hrep.generators)):
        if self.hrep.is_vertex[i]:
            self.max_point = np.maximum(self.max_point, self.hrep.generators[i])
            self.min_point = np.minimum(self.min_point, self.hrep.generators[i])</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Polyhedron2D.determine_plot_size"><code class="name flex">
<span>def <span class="ident">determine_plot_size</span></span>(<span>self, padding=[-1, 2])</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def determine_plot_size(self, padding = [-1, 2]):
    if self.min_point is None or self.max_point is None:
        self.determine_hull_size()
    self.xlim = [self.min_point[0], self.max_point[0]]
    self.ylim = [self.min_point[1], self.max_point[1]]
    if len(self.ray_indices) &gt; 0:
        current_point = self.ray_indices[0]
        ray = self.hrep.generators[current_point]
        if self.hrep.is_vertex[self.hrep.adj[self.ray_indices[0]][0]]:
            vertex = self.hrep.generators[self.hrep.adj[self.ray_indices[0]][0]]
            next_point = self.hrep.adj[self.ray_indices[0]][0]
        else:
            vertex = self.hrep.generators[
                self.hrep.adj[self.ray_indices[0]][1]]
            next_point = self.hrep.adj[self.ray_indices[0]][1]
        if ray[0] &lt; 0:
            x_lim = old_div((vertex[0] - self.min_point[0]),-float(ray[0]))
        elif ray[0] &gt; 0:
            x_lim = old_div((self.max_point[0] - vertex[0]),-float(ray[0]))
        else:
            x_lim = 10000
        if ray[1] &lt; 0:
            y_lim = old_div((vertex[1] - self.min_point[1]),-float(ray[1]))
        elif ray[1] &gt; 0:
            y_lim = old_div((self.max_point[1] - vertex[1]),-float(ray[1])) 
        else:
            y_lim = 10000
        lim = min(x_lim, y_lim) + 1
        plot_max = np.maximum(self.max_point, vertex + lim*ray)
        plot_min = np.minimum(self.min_point, vertex + lim*ray)
        self.xlim = [plot_min[0], plot_max[0]]
        self.ylim = [plot_min[1], plot_max[1]]
    else:
        current_point = 0
        next_point = self.hrep.adj[0][0]
    for _ in range(len(self.hrep.generators)):
        prev_point = current_point
        current_point = next_point
        if not self.hrep.is_vertex[current_point]:
            ray = self.hrep.generators[current_point]
            vertex = self.hrep.generators[prev_point]
            if ray[0] &lt; 0:
                x_lim = old_div((vertex[0] - self.min_point[0]),-float(ray[0]))
            elif ray[0] &gt; 0:
                x_lim = old_div((self.max_point[0] - vertex[0]),float(ray[0]))
            else:
                x_lim = 10000
            if ray[1] &lt; 0:
                y_lim = old_div((vertex[1] - self.min_point[1]),-float(ray[1]))
            elif ray[1] &gt; 0:
                y_lim = old_div((self.max_point[1] - vertex[1]),float(ray[1]))
            else:
                y_lim = 10000 
            lim = min(x_lim, y_lim) + 1
            plot_max = np.maximum(self.max_point, vertex + lim*ray)
            plot_min = np.minimum(self.min_point, vertex + lim*ray)
            self.xlim = [plot_min[0], plot_max[0]]
            self.ylim = [plot_min[1], plot_max[1]]
            break
        if self.hrep.adj[current_point][0] != prev_point:
            next_point = self.hrep.adj[current_point][0]
        else:
            next_point = self.hrep.adj[current_point][1]

    self.xlim = np.array(np.floor([self.xlim[i] + padding[i] for i in [0,1]]))
    self.ylim = np.array(np.floor([self.ylim[i] + padding[i] for i in [0,1]]))</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.polyhedron2D.Polyhedron2D.make_integer_hull"><code class="name flex">
<span>def <span class="ident">make_integer_hull</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_integer_hull(self):
    if self.min_point is None or self.max_point is None:
        self.determine_hull_size()
    v = []
    for i in range(int(ceil(round(self.min_point[0], 3))), 
                   int(ceil(round(self.max_point[0], 3)))+1):
        for j in range(int(ceil(round(self.min_point[1], 3))), 
                       int(ceil(round(self.max_point[1], 3)))+1):
            if np.alltrue(np.dot(self.hrep.A, [i, j]) &lt;= self.hrep.b):
                v.append([i, j])
    r = [self.hrep.generators[self.ray_indices[i]].tolist() 
         for i in range(len(self.ray_indices))]
    return Polyhedron2D(points = v, rays = r)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coinor.grumpy" href="index.html">coinor.grumpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coinor.grumpy.polyhedron2D.Figure" href="#coinor.grumpy.polyhedron2D.Figure">Figure</a></code></h4>
<ul class="two-column">
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.__init__" href="#coinor.grumpy.polyhedron2D.Figure.__init__">__init__</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.add_line" href="#coinor.grumpy.polyhedron2D.Figure.add_line">add_line</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.add_line_segment" href="#coinor.grumpy.polyhedron2D.Figure.add_line_segment">add_line_segment</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.add_point" href="#coinor.grumpy.polyhedron2D.Figure.add_point">add_point</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.add_polyhedron" href="#coinor.grumpy.polyhedron2D.Figure.add_polyhedron">add_polyhedron</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.add_text" href="#coinor.grumpy.polyhedron2D.Figure.add_text">add_text</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.initialize" href="#coinor.grumpy.polyhedron2D.Figure.initialize">initialize</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.set_xlim" href="#coinor.grumpy.polyhedron2D.Figure.set_xlim">set_xlim</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.set_ylim" href="#coinor.grumpy.polyhedron2D.Figure.set_ylim">set_ylim</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Figure.show" href="#coinor.grumpy.polyhedron2D.Figure.show">show</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coinor.grumpy.polyhedron2D.Polyhedron2D" href="#coinor.grumpy.polyhedron2D.Polyhedron2D">Polyhedron2D</a></code></h4>
<ul class="">
<li><code><a title="coinor.grumpy.polyhedron2D.Polyhedron2D.__init__" href="#coinor.grumpy.polyhedron2D.Polyhedron2D.__init__">__init__</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Polyhedron2D.determine_hull_size" href="#coinor.grumpy.polyhedron2D.Polyhedron2D.determine_hull_size">determine_hull_size</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Polyhedron2D.determine_plot_size" href="#coinor.grumpy.polyhedron2D.Polyhedron2D.determine_plot_size">determine_plot_size</a></code></li>
<li><code><a title="coinor.grumpy.polyhedron2D.Polyhedron2D.make_integer_hull" href="#coinor.grumpy.polyhedron2D.Polyhedron2D.make_integer_hull">make_integer_hull</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>