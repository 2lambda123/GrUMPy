%
% API Documentation for API Documentation
% Module coinor.grumpy.BB
%
% Generated by epydoc 3.0.1
% [Mon Feb 02 20:43:49 2015]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}|(}
\section{Module coinor.grumpy.BB}

    \label{coinor:grumpy:BB}
\textbf{Author:} Brady Hunsaker, Osman Ozaltin, Ted Ralphs, Aykut Bulut




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{coinor:grumpy:BB:CreatePerlStyleBooleanFlag}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.CreatePerlStyleBooleanFlag \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{CreatePerlStyleBooleanFlag}(\textit{parser}, \textit{flag\_text}, \textit{variable\_name}, \textit{help\_text})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Add two options to an optparse.OptionParser, one with a 'no' prefix.
Two options are created.  One has the flag\_text and one has 'no' prepended
to the flag\_text.  For example, --foo and --nofoo.  This is similar to a
common style in Perl.
Args:
  parser: optparse.OptionParser object.
  flag\_text: String text for the flag.
  variable\_name: String name of the variable to store the flag results.
  help\_text: String that describes the flag.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:parse_options}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.parse\_options \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{parse\_options}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Parse arguments and flags

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-m\-a\-i\-n\-t\-a\-i\-n\-e\-r\-\_\-\_\- & \raggedright This package is for visualizing branch-and-bound. It also 
          contains a basic branch-and-bound implementation primarily for 
          classroom and educational use.

          Communication with solvers is through a grammar described in 
          separate documentation. Solvers can interface to this class in a 
          number of different ways and a number of different types of 
          images may be created.

          Images at intervals that can be specified on the command line as 
          well as after new incumbent solutions are found.

          Note that the generation of tree images takes significantly 
          longer than other images because every node appears in the image.

\textbf{Value:} 
{\tt \texttt{'}\texttt{Aykut Bulut (aykut@lehigh.edu)}\texttt{'}}&\\
\cline{1-2}
\raggedright B\-R\-A\-N\-C\-H\-\_\-S\-T\-R\-A\-T\-E\-G\-Y\- & \raggedright \textbf{Value:} 
{\tt None}&\\
\cline{1-2}
\raggedright S\-E\-A\-R\-C\-H\-\_\-S\-T\-R\-A\-T\-E\-G\-Y\- & \raggedright \textbf{Value:} 
{\tt None}&\\
\cline{1-2}
\raggedright M\-O\-S\-T\-\_\-F\-R\-A\-C\-T\-I\-O\-N\-A\-L\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Most Fraction}\texttt{'}}&\\
\cline{1-2}
\raggedright F\-I\-X\-E\-D\-\_\-B\-R\-A\-N\-C\-H\-I\-N\-G\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Fixed Branching}\texttt{'}}&\\
\cline{1-2}
\raggedright P\-S\-E\-U\-D\-O\-C\-O\-S\-T\-\_\-B\-R\-A\-N\-C\-H\-I\-N\-G\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Pseudocost Branching}\texttt{'}}&\\
\cline{1-2}
\raggedright D\-E\-P\-T\-H\-\_\-F\-I\-R\-S\-T\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Depth First}\texttt{'}}&\\
\cline{1-2}
\raggedright B\-E\-S\-T\-\_\-F\-I\-R\-S\-T\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Best First}\texttt{'}}&\\
\cline{1-2}
\raggedright B\-E\-S\-T\-\_\-E\-S\-T\-I\-M\-A\-T\-E\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Best Estimate}\texttt{'}}&\\
\cline{1-2}
\raggedright I\-N\-F\-I\-N\-I\-T\-Y\- & \raggedright \textbf{Value:} 
{\tt 2147483647}&\\
\cline{1-2}
\raggedright D\-O\-T\-2\-T\-E\-X\-\_\-T\-E\-M\-P\-L\-A\-T\-E\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{{\textbackslash}n{\textbackslash}{\textbackslash}documentclass[landscape]\{article\}{\textbackslash}n{\textbackslash}{\textbackslash}usepackage[x11n}\texttt{...}}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{coinor.grumpy}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}|(}
\subsection{Class BBTree}

    \label{coinor:grumpy:BB:BBTree}
\begin{tabular}{cccccccccccc}
% Line for object, linespec=[False, False, False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
&&
&&
  \\
% Line for src.gimpy.graph.Graph, linespec=[False, False, False]
\multicolumn{4}{r}{\settowidth{\BCL}{src.gimpy.graph.Graph}\multirow{2}{\BCL}{src.gimpy.graph.Graph}}
&&
&&
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
&&
&&
  \\
% Line for src.gimpy.tree.Tree, linespec=[False, False]
\multicolumn{6}{r}{\settowidth{\BCL}{src.gimpy.tree.Tree}\multirow{2}{\BCL}{src.gimpy.tree.Tree}}
&&
&&
  \\\cline{7-7}
  &&&&&&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for src.gimpy.tree.BinaryTree, linespec=[False]
\multicolumn{8}{r}{\settowidth{\BCL}{src.gimpy.tree.BinaryTree}\multirow{2}{\BCL}{src.gimpy.tree.BinaryTree}}
&&
  \\\cline{9-9}
  &&&&&&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&&&&&\multicolumn{2}{l}{\textbf{coinor.grumpy.BB.BBTree}}
\end{tabular}

Methods to process and visualize information about a b\&b tree. It can 
process an output file (in a specific format, see BAK project in COIN-OR) 
of a solver that has three information. See run.py in examples directory 
fot this use. Moreover it implements a branch and bound method that can 
solve binary programs (0-1 variables only) using PuLP as an LP solver. It 
provides different branching and searching strategies. See 
test\_strategies.py in test directory.

This is the main class of GrUMPy. It inherits BinaryTree from GIMPy and 
keeps the entire branch-and-bound tree in self.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, **\textit{attrs})

\setlength{\parskip}{2ex}
\begin{alltt}

API: \_\_init\_\_(self, **attrs)
Description:
    Class constructor.
Input:
    attrs: Tree attributes in keyword arguments format. See Graph and
    Tree class for details.
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:process_file}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.process\_file \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{process\_file}(\textit{self}, \textit{file\_name})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:write_as_dynamic_gexf}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.write\_as\_dynamic\_gexf \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{write\_as\_dynamic\_gexf}(\textit{self}, \textit{filename}, \textit{mode}={\tt \texttt{'}\texttt{Dot}\texttt{'}})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_display\_mode}(\textit{self}, \textit{mode})

\setlength{\parskip}{2ex}
\begin{alltt}

API:
    set\_display\_mode(self, value)
Description:
    Sets display mode to value.
Input:
    value: New display mode.
Post:
    Display mode attribute of graph is updated.
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: src.gimpy.graph.Graph.set\_display\_mode 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{display}(\textit{self}, \textit{item}={\tt \texttt{'}\texttt{all}\texttt{'}}, \textit{basename}={\tt \texttt{'}\texttt{graph}\texttt{'}}, \textit{format}={\tt \texttt{'}\texttt{png}\texttt{'}}, \textit{count}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Displays/Saves images requested. BranchAndBound method calls this 
    method to visualize the branch and bound tree.

\setlength{\parskip}{1ex}
      Overrides: src.gimpy.graph.Graph.display

    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:display_all}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.display\_all \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{display\_all}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Assumes all the images have the same size.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:display_image}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.display\_image \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{display\_image}(\textit{self}, \textit{gnuplot})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:set_label}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.set\_label \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_label}(\textit{self}, \textit{label})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:set_logscaley}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.set\_logscaley \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_logscaley}(\textit{self}, \textit{boolean})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:set_fathom}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.set\_fathom \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_fathom}(\textit{self}, \textit{boolean})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:set_edge_limit}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.set\_edge\_limit \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_edge\_limit}(\textit{self}, \textit{limit})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:set_sample_tree}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.set\_sample\_tree \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_sample\_tree}(\textit{self}, \textit{number})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:AddOrUpdateNode}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.AddOrUpdateNode \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{AddOrUpdateNode}(\textit{self}, \textit{id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{status}, \textit{lp\_bound}, \textit{integer\_infeasibility\_count}, \textit{integer\_infeasibility\_sum}, **\textit{attrs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This method designed to update nodes (in BAK) but we use it for 
    updating/adding arcs. This is because of the tree data structure the 
    authors adopted in BAK. We can divide these attributes such that some 
    will belong to the edge parent\_id-{\textgreater}id and the others 
    belong to the id node. The following shows whether the attribute 
    belongs to edge or node. branch direction -{\textgreater} edge status 
    -{\textgreater} node lp\_bound -{\textgreater} node 
    integer\_infeasibility\_count -{\textgreater} node 
    integer\_infeasibility\_sum -{\textgreater} node parent\_id 
    -{\textgreater} node

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:IsBetterThan}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.IsBetterThan \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{IsBetterThan}(\textit{self}, \textit{value1}, \textit{value2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Returns True if value1 is better than value2 as an objective value.
This depends on the optimization sense of the instance.
Args:
  value1: Float.
  value2: Float.
Returns:
  True if value1 is better than value2 as an objective value.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:IsBetterThanIncumbent}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.IsBetterThanIncumbent \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{IsBetterThanIncumbent}(\textit{self}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Returns True if the passed value is better than current incumbent.
Args:
  value: Float to use for comparison.
Returns:
  True if the passed value is better than the current incumbent.
  'Better' is determined by the sense of optimization.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:UpdateObjectiveValueLimits}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.UpdateObjectiveValueLimits \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpdateObjectiveValueLimits}(\textit{self}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}
Updates the min and max objective values if appropriate.
Args:
  value: Float objective value.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:AddProgressMeasures}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.AddProgressMeasures \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{AddProgressMeasures}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GetImageCounterString}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GetImageCounterString \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetImageCounterString}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a string with the image counter.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:WriteHistogramScript}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.WriteHistogramScript \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{WriteHistogramScript}(\textit{self}, \textit{num\_bins}, \textit{bin\_width}, \textit{max\_bin\_count}, \textit{lp\_bound}, \textit{data\_filename}, \textit{output\_file})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Write a Gnuplot script file to generate a histogram image.
Args:
  num\_bins: Integer number of bins for the histogram.
  bin\_width: Float width of the bins in terms of objective values.
  max\_bin\_count: Integer number of the highest bin count.
  lp\_bound: Float value of the current LP bound.
  data\_filename: String name of the file; used for display purposes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:AdjustHistogramEndBins}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.AdjustHistogramEndBins \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{AdjustHistogramEndBins}(\textit{self}, \textit{objective\_list}, \textit{num\_bins}, \textit{bin\_width}, \textit{bin\_counts}, \textit{bin\_centers}, \textit{bin\_widths})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Adjusts the two end bins if necessary to make them narrower.
The two end bins may need to be narrower than the other bins so that
they do not go past the current incumbent value on one end and the
current lp bound on the other.  So that the histogram is still correct
in areas, the height of these bins needs to be adjusted so that the
area does not change.

Note that there is likely to be some bias toward taller bins on
the ends since they always have a point at one end of their width.  It
may be more accurate visually to ignore or discount that one point when
determining the bin height, but that is not currently done.

Args:
  objective\_list: List of float objective values.
  num\_bins: Integer number of bins.
  bin\_width: Float standard width of bins in terms of objective values.
  bin\_counts: List of integer counts for each bin.
  bin\_centers: List of float coordinates for the center of each bin.
  bin\_widths: List of float widths for bins, allowing for individualized
    widths.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateHistogram}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateHistogram \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateHistogram}(\textit{self}, \textit{output\_file}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Generate files necessary for a histogram image.
Two files are necessary: a data file and a Gnuplot script file (which
references the data file).
Args:
  time: Float number of seconds since the start of optimization.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GetImageObjectiveBounds}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GetImageObjectiveBounds \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetImageObjectiveBounds}(\textit{self}, \textit{min\_value}, \textit{max\_value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Return min and max bounds to be used for images.
Images should use bounds that are slightly wider than observed
objective values.  Also, the special case of a single value must be
handled.
Args:
  min\_value: Float minimum objective value.
  max\_value: Float maximum objective value.
Returns:
  A tuple of two float values (lower\_bound, upper\_bound).
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:WriteScatterplotScript}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.WriteScatterplotScript \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{WriteScatterplotScript}(\textit{self}, \textit{data\_filename}, \textit{output\_file})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Write a Gnuplot script file to generate a scatterplot image.
Args:
  data\_filename: String name of the file; used for display purposes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateScatterplot}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateScatterplot \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateScatterplot}(\textit{self}, \textit{output\_file}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Generate files necessary for a scatterplot image.
Two files are necessary: a data file and a Gnuplot script file (which
references the data file).
Args:
    output\_file: if not given the gnuplot image will not be written
to disk but returned (to be displayed in pygame window)
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:WriteIncumbentPathScript}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.WriteIncumbentPathScript \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{WriteIncumbentPathScript}(\textit{self}, \textit{data\_filename})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Write a Gnuplot script file to generate an incumbent path image.
Args:
  data\_filename: String name of the file; used for display purposes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:WriteAllIncumbentPathsScript}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.WriteAllIncumbentPathsScript \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{WriteAllIncumbentPathsScript}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Return a Gnuplot script string to generate an incumbent path image.
Args:
  data\_filenames: List of string names of files.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateIncumbentPath}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateIncumbentPath \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateIncumbentPath}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Generate files necessary for an incumbent scatterplot path image. Two 
    files are necessary: a data file and a Gnuplot script file (which 
    references the data file).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateAllIncumbentPaths}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateAllIncumbentPaths \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateAllIncumbentPaths}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Generate file for a path image with all incumbent paths. Data files 
    were previously generated for each incumbent.  This re-uses those 
    files.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:WriteTreeScript}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.WriteTreeScript \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{WriteTreeScript}(\textit{self}, \textit{additional\_lines}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Write a Gnuplot script file to generate a tree image.
Args:
  additional\_lines: String with additional lines to be added to the
    script file.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GetTreeFixedHorizontalPositions}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GetTreeFixedHorizontalPositions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetTreeFixedHorizontalPositions}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Returns horizontal positions for all nodes based on fixed positions.
Returns:
  Dictionary of float horizontal positions, keyed by node id.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GetTreeHorizontalPositions}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GetTreeHorizontalPositions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetTreeHorizontalPositions}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Returns horizontal positions for all nodes.
Each node is given equal horizontal space.
Returns:
  Dictionary of float horizontal positions, keyed by node id.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:WriteDataFileFromList}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.WriteDataFileFromList \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{WriteDataFileFromList}(\textit{self}, \textit{filename}, \textit{data\_list})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Write a list of string data to a file with one entry per line.
Args:
  filename: String filename to open.
  data\_list: List of string values to write.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateTreeImage}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateTreeImage \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateTreeImage}(\textit{self}, \textit{fixed\_horizontal\_positions}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Generate files necessary for a tree image. Two files are necessary: a 
    data file and a Gnuplot script file (which references the data file).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessLine}(\textit{self}, \textit{line})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Process a line of the input file, generating images if appropriate.
Parses the line, updates internal data structures, and creates images
if appropriate.
Args:
  line: String input line to process.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessHeuristicLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessHeuristicLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessHeuristicLine}(\textit{self}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'heuristic'.
Args:
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessIntegerLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessIntegerLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessIntegerLine}(\textit{self}, \textit{node\_id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'integer'.
Args:
  node\_id: String node id.
  parent\_id: String node id of parent.
  branch\_direction: String of 'L' or 'R' indicating whether this node
  is the left or right child of its parent.
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessFathomedLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessFathomedLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessFathomedLine}(\textit{self}, \textit{node\_id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'fathomed'.
Args:
  node\_id: String node id.
  parent\_id: String node id of parent.
  branch\_direction: String of 'L' or 'R' indicating whether this node is
    the left or right child of its parent.
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessPregnantLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessPregnantLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessPregnantLine}(\textit{self}, \textit{node\_id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'pregnant'.
Args:
  node\_id: String node id.
  parent\_id: String node id of parent.
  branch\_direction: String of 'L' or 'R' indicating whether this node is
    the left or right child of its parent.
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessBranchedLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessBranchedLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessBranchedLine}(\textit{self}, \textit{node\_id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'branched'.
Args:
  node\_id: String node id.
  parent\_id: String node id of parent.
  branch\_direction: String of 'L' or 'R' indicating whether this node
  is the left or right child of its parent.
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessInfeasibleLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessInfeasibleLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessInfeasibleLine}(\textit{self}, \textit{node\_id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'infeasible'.
Args:
  node\_id: String node id.
  parent\_id: String node id of parent.
  branch\_direction: String of 'L' or 'R' indicating whether this node is
    the left or right child of its parent.
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:ProcessCandidateLine}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.ProcessCandidateLine \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ProcessCandidateLine}(\textit{self}, \textit{node\_id}, \textit{parent\_id}, \textit{branch\_direction}, \textit{remaining\_tokens})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Core processing for a line of type 'candidate'.
Args:
  node\_id: String node id.
  parent\_id: String node id of parent.
  branch\_direction: String of 'L' or 'R' indicating whether this node
  is the left or right child of its parent.
  remaining\_tokens: List of string tokens. These are those that remain
    after any common tokens are processed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:RunGnuplotOnAllFiles}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.RunGnuplotOnAllFiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{RunGnuplotOnAllFiles}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Runs Gnuplot on all files in self.\_gnuplot\_files.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:CreateAnimatedImages}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.CreateAnimatedImages \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{CreateAnimatedImages}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Create animated images based on the static images.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GeneratePredictionImages}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GeneratePredictionImages \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GeneratePredictionImages}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateForecastImages}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateForecastImages \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateForecastImages}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:GenerateRandomMIP}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.GenerateRandomMIP \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GenerateRandomMIP}(\textit{self}, \textit{numVars}={\tt 40}, \textit{numCons}={\tt 20}, \textit{density}={\tt 0.2}, \textit{maxObjCoeff}={\tt 10}, \textit{maxConsCoeff}={\tt 10}, \textit{tightness}={\tt 2}, \textit{rand\_seed}={\tt 2})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:grumpy:BB:BBTree:BranchAndBound}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}!coinor.grumpy.BB.BBTree.BranchAndBound \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{BranchAndBound}(\textit{self}, \textit{CONSTRAINTS}, \textit{VARIABLES}, \textit{OBJ}, \textit{MAT}, \textit{RHS}, \textit{branch\_strategy}={\tt \texttt{'}\texttt{Most Fraction}\texttt{'}}, \textit{search\_strategy}={\tt \texttt{'}\texttt{Depth First}\texttt{'}}, \textit{complete\_enumeration}={\tt False}, \textit{display\_interval}={\tt None}, \textit{binary\_vars}={\tt True})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from src.gimpy.tree.BinaryTree}}}

\begin{quote}
add\_left\_child(), add\_right\_child(), add\_root(), bfs(), del\_node(), dfs(), get\_left\_child(), get\_right\_child(), postordereval(), print\_nodes(), printexp(), traverse()
\end{quote}

\large{\textbf{\textit{Inherited from src.gimpy.tree.Tree}}}

\begin{quote}
add\_child(), get\_children(), get\_parent()
\end{quote}

\large{\textbf{\textit{Inherited from src.gimpy.graph.Graph}}}

\begin{quote}
\_\_contains\_\_(), \_\_repr\_\_(), add\_edge(), add\_node(), augment\_cycle(), check\_edge(), create(), create\_cluster(), create\_residual\_graph(), cycle\_canceling(), del\_edge(), edge\_to\_string(), fifo\_label\_correcting(), find\_cycle\_capacity(), find\_feasible\_flow(), floyd\_warshall(), floyd\_warshall\_get\_cycle(), floyd\_warshall\_get\_path(), get\_degree(), get\_diameter(), get\_edge\_attr(), get\_edge\_cost(), get\_edge\_list(), get\_edge\_num(), get\_in\_neighbors(), get\_layout(), get\_negative\_cycle(), get\_neighbors(), get\_node(), get\_node\_attr(), get\_node\_list(), get\_node\_num(), get\_out\_neighbors(), get\_simplex\_solution\_graph(), label\_components(), label\_correcting\_check\_cycle(), label\_correcting\_get\_cycle(), label\_strong\_component(), max\_flow(), max\_flow\_preflowpush(), min\_cost\_flow(), minimum\_spanning\_tree\_kruskal(), minimum\_spanning\_tree\_prim(), network\_simplex(), page\_rank(), print\_flow(), process\_edge\_dijkstra(), process\_edge\_flow(), process\_edge\_prim(), process\_edge\_search(), process\_node\_search(), random(), relabel(), search(), set\_edge\_attr(), set\_layout(), set\_node\_attr(), show\_flow(), simplex\_augment\_cycle(), simplex\_compute\_potentials(), simplex\_connect(), simplex\_determine\_leaving\_arc(), simplex\_find\_cycle(), simplex\_find\_tree(), simplex\_identify\_cycle(), simplex\_mark\_entering\_arc(), simplex\_mark\_leaving\_arc(), simplex\_mark\_st\_arcs(), simplex\_optimal(), simplex\_redraw(), simplex\_remove\_arc(), simplex\_search(), simplex\_select\_entering\_arc(), strong\_connect(), tarjan(), to\_string(), write()
\end{quote}

\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}!coinor.grumpy.BB.BBTree \textit{(class)}|)}
    \index{coinor \textit{(package)}!coinor.grumpy \textit{(package)}!coinor.grumpy.BB \textit{(module)}|)}
